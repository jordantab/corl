[
    {
        "instruction": "Provide an optimized version of the following code snippet.",
        "input": "#include<bits/stdc++.h>\n\n\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n\n#define rep(i,n) REP(i,0,n)\n\n\n\nusing namespace std;\n\n\n\nconst int IINF = INT_MAX;\n\n\n\nint H,W,mini,field[10][10],prev[10][10],mindist[10][10],nfield[10][10],mindist2[10][10],m1[10][10],m2[10][10];\n\nvector<int> sp[2];\n\nbool visited[10][10];\n\nint dx[] = {0,1,0,-1};\n\nint dy[] = {1,0,-1,0};\n\nbool X[10], Y[10];\n\n\n\nbool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\n\n\nvoid simulate_min(int dist[10][10],int f[10][10],int s){\n\n  rep(i,H) rep(j,W) dist[i][j] = IINF;\n\n  dist[s/W][s%W] = 0;\n\n  deque<int> deq;\n\n  deq.push_back(s);\n\n  while( !deq.empty() ){\n\n    int cur = deq.front(); deq.pop_front();\n\n    int x = cur % W, y = cur / W;\n\n    rep(i,4){\n\n      int nx = x + dx[i], ny = y + dy[i];\n\n      if( !isValid(nx,ny) ) continue;\n\n      if( f[ny][nx] != 0 && f[ny][nx] != f[s/W][s%W] ) continue;\n\n      if( dist[ny][nx] == IINF ) {\n\n        dist[ny][nx] = dist[y][x] + 1;\n\n        deq.push_back(nx+ny*W);\n\n      }\n\n    }\n\n  }\n\n}\n\n\n\n\n\nvoid dfs(int x,int y,int cost,int f[10][10],int ep,deque<int> &path,int F,int S,int prev){\n\n\n\n  if( x + y * W == ep ) {\n\n    rep(i,H) rep(j,W) nfield[i][j] = field[i][j];\n\n    rep(i,path.size()) nfield[path[i]/W][path[i]%W] = 1;\n\n    simulate_min(mindist2,nfield,sp[S][0]);\n\n    if( mindist2[sp[S][1]/W][sp[S][1]%W] == IINF ) return;\n\n    mini = min(mini,(int)path.size()-1+mindist2[sp[S][1]/W][sp[S][1]%W]);\n\n    return;\n\n  }\n\n  if( cost >= mini ) return;\n\n  if( m2[sp[S][1]/W][sp[S][1]%W] + cost >= mini ) return;\n\n\n\n  int cnt = 0;\n\n  rep(i,4) {\n\n    int nx = x + dx[i], ny = y + dy[i];\n\n    if( !isValid(nx,ny) ) continue;\n\n    cnt += visited[ny][nx];\n\n }\n\n  if( cnt >= 2 ) return;\n\n\n\n  {\n\n    rep(i,4){\n\n      int nx = x, ny = y;\n\n      nx += dx[i], ny += dy[i];\n\n      if( !isValid(nx,ny) ) continue;\n\n      if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;\n\n      if( visited[ny][nx] ) continue;\n\n      while(1){\n\n        nx += dx[i], ny += dy[i];\n\n        if( !isValid(nx,ny) ) break;\n\n        if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) break;\n\n        if( X[nx] || Y[ny] ) break;\n\n        if( visited[ny][nx] ) return;\n\n      }\n\n    }\n\n  }\n\n\n\n\n\n  rep(i,4) {\n\n    if( i == (prev+2) % 4 ) continue;\n\n    int nx = x + dx[i], ny = y + dy[i];\n\n    if( !isValid(nx,ny) ) continue;\n\n    if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;\n\n    if( visited[ny][nx] ) continue;\n\n    visited[ny][nx] = true;\n\n    path.push_back(nx+ny*W);\n\n    dfs(nx,ny,cost+1,f,ep,path,F,S,i);\n\n    path.pop_back();\n\n    visited[ny][nx] = false;\n\n  }\n\n\n\n\n\n}\n\n\n\nint compute(int F,int S){\n\n  rep(i,H) rep(j,W) visited[i][j] = false;\n\n  deque<int> path;\n\n  path.push_back(sp[F][0]);\n\n  visited[sp[F][0]/W][sp[F][0]%W] = true;\n\n  simulate_min(m1,field,sp[F][0]);\n\n  simulate_min(m2,field,sp[S][0]);\n\n  dfs(sp[F][0]%W,sp[F][0]/W,0,field,sp[F][1],path,F,S,-IINF);\n\n}\n\n\n\nint main(){\n\n  while( cin >> H >> W, H|W ){\n\n    rep(i,2) sp[i].clear();\n\n    rep(i,10) X[i] = Y[i] = false;\n\n    rep(i,H) rep(j,W) {\n\n      cin >> field[i][j];\n\n      if( field[i][j] == 1 ) X[j] = true, Y[i] = true;\n\n      if( field[i][j] == 2 ) sp[0].push_back(j+i*W), X[j] = Y[i] = true;\n\n      if( field[i][j] == 3 ) sp[1].push_back(j+i*W), X[j] = Y[i] = true;\n\n    }\n\n    mini = IINF;\n\n\n\n    compute(0,1);\n\n    if( mini == IINF ) puts(\"0\");\n\n    else cout << mini << endl;\n\n  }\n\n  return 0;\n\n}",
        "output": "#include<bits/stdc++.h>\n\n\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n\n#define rep(i,n) REP(i,0,n)\n\n\n\nusing namespace std;\n\n\n\nconst int IINF = INT_MAX;\n\n\n\nint H,W,mini,field[10][10],prev[10][10],mindist[10][10],nfield[10][10],mindist2[10][10],m1[10][10],m2[10][10];\n\nvector<int> sp[2];\n\nbool visited[10][10];\n\nint dx[] = {0,1,0,-1};\n\nint dy[] = {1,0,-1,0};\n\nbool X[10], Y[10];\n\n\n\nbool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\n\n\nvoid simulate_min(int dist[10][10],int f[10][10],int s){\n\n  rep(i,H) rep(j,W) dist[i][j] = IINF;\n\n  dist[s/W][s%W] = 0;\n\n  deque<int> deq;\n\n  deq.push_back(s);\n\n  while( !deq.empty() ){\n\n    int cur = deq.front(); deq.pop_front();\n\n    int x = cur % W, y = cur / W;\n\n    rep(i,4){\n\n      int nx = x + dx[i], ny = y + dy[i];\n\n      if( !isValid(nx,ny) ) continue;\n\n      if( f[ny][nx] != 0 && f[ny][nx] != f[s/W][s%W] ) continue;\n\n      if( dist[ny][nx] == IINF ) {\n\n        dist[ny][nx] = dist[y][x] + 1;\n\n        deq.push_back(nx+ny*W);\n\n      }\n\n    }\n\n  }\n\n}\n\n\n\n\n\nvoid dfs(int x,int y,int cost,int f[10][10],int ep,deque<int> &path,int F,int S,int prev){\n\n\n\n  if( cost >= mini ) return;\n\n  if( m2[sp[S][1]/W][sp[S][1]%W] + cost >= mini ) return;\n\n\n\n\n\n\n\n\n\n\n\n  if( x + y * W == ep ) {\n\n    rep(i,H) rep(j,W) nfield[i][j] = field[i][j];\n\n    rep(i,path.size()) nfield[path[i]/W][path[i]%W] = 1;\n\n    simulate_min(mindist2,nfield,sp[S][0]);\n\n    if( mindist2[sp[S][1]/W][sp[S][1]%W] == IINF ) return;\n\n    mini = min(mini,(int)path.size()-1+mindist2[sp[S][1]/W][sp[S][1]%W]);\n\n    return;\n\n  }\n\n  int cnt = 0;\n\n  rep(i,4) {\n\n    int nx = x + dx[i], ny = y + dy[i];\n\n    if( !isValid(nx,ny) ) continue;\n\n    cnt += visited[ny][nx];\n\n }\n\n  if( cnt >= 2 ) return;\n\n\n\n\n\n  {\n\n    rep(i,4){\n\n      int nx = x, ny = y;\n\n      nx += dx[i], ny += dy[i];\n\n      if( !isValid(nx,ny) ) continue;\n\n      if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;\n\n      if( visited[ny][nx] ) continue;\n\n      while(1){\n\n        nx += dx[i], ny += dy[i];\n\n        if( !isValid(nx,ny) ) break;\n\n        if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) break;\n\n        if( X[nx] || Y[ny] ) break;\n\n        if( visited[ny][nx] ) return;\n\n      }\n\n    }\n\n  }\n\n\n\n\n\n  rep(i,4) {\n\n    if( i == (prev+2) % 4 ) continue;\n\n    int nx = x + dx[i], ny = y + dy[i];\n\n    if( !isValid(nx,ny) ) continue;\n\n    if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;\n\n    if( visited[ny][nx] ) continue;\n\n    visited[ny][nx] = true;\n\n    path.push_back(nx+ny*W);\n\n    dfs(nx,ny,cost+1,f,ep,path,F,S,i);\n\n    path.pop_back();\n\n    visited[ny][nx] = false;\n\n  }\n\n\n\n\n\n}\n\n\n\nint compute(int F,int S){\n\n  rep(i,H) rep(j,W) visited[i][j] = false;\n\n  deque<int> path;\n\n  path.push_back(sp[F][0]);\n\n  visited[sp[F][0]/W][sp[F][0]%W] = true;\n\n  simulate_min(m1,field,sp[F][0]);\n\n  simulate_min(m2,field,sp[S][0]);\n\n  dfs(sp[F][0]%W,sp[F][0]/W,0,field,sp[F][1],path,F,S,-IINF);\n\n}\n\n\n\nint main(){\n\n  while( cin >> H >> W, H|W ){\n\n    rep(i,2) sp[i].clear();\n\n    rep(i,10) X[i] = Y[i] = false;\n\n    rep(i,H) rep(j,W) {\n\n      cin >> field[i][j];\n\n      if( field[i][j] == 1 ) X[j] = true, Y[i] = true;\n\n      if( field[i][j] == 2 ) sp[0].push_back(j+i*W), X[j] = Y[i] = true;\n\n      if( field[i][j] == 3 ) sp[1].push_back(j+i*W), X[j] = Y[i] = true;\n\n    }\n\n    mini = IINF;\n\n\n\n    compute(0,1);\n\n    if( mini == IINF ) puts(\"0\");\n\n    else cout << mini << endl;\n\n  }\n\n  return 0;\n\n}"
    },
    {
        "instruction": "Provide an optimized version of the following code snippet.",
        "input": "#include<bits/stdc++.h>\n\n\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n\n#define rep(i,n) REP(i,0,n)\n\n\n\nusing namespace std;\n\n\n\nconst int IINF = INT_MAX;\n\n\n\nint H,W,mini,field[10][10],prev[10][10],mindist[10][10],nfield[10][10],mindist2[10][10],m1[10][10],m2[10][10];\n\nvector<int> sp[2];\n\nbool visited[10][10];\n\nint dx[] = {0,1,0,-1};\n\nint dy[] = {1,0,-1,0};\n\nbool X[10], Y[10];\n\n\n\nbool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\n\n\nvoid simulate_min(int dist[10][10],int f[10][10],int s){\n\n  rep(i,H) rep(j,W) dist[i][j] = IINF;\n\n  dist[s/W][s%W] = 0;\n\n  deque<int> deq;\n\n  deq.push_back(s);\n\n  while( !deq.empty() ){\n\n    int cur = deq.front(); deq.pop_front();\n\n    int x = cur % W, y = cur / W;\n\n    rep(i,4){\n\n      int nx = x + dx[i], ny = y + dy[i];\n\n      if( !isValid(nx,ny) ) continue;\n\n      if( f[ny][nx] != 0 && f[ny][nx] != f[s/W][s%W] ) continue;\n\n      if( dist[ny][nx] == IINF ) {\n\n        dist[ny][nx] = dist[y][x] + 1;\n\n        deq.push_back(nx+ny*W);\n\n      }\n\n    }\n\n  }\n\n}\n\n\n\n\n\nvoid dfs(int x,int y,int cost,int f[10][10],int ep,deque<int> &path,int F,int S,int prev){\n\n\n\n  if( cost >= mini ) return;\n\n  if( m2[sp[S][1]/W][sp[S][1]%W] + cost >= mini ) return;\n\n\n\n\n\n\n\n\n\n\n\n  if( x + y * W == ep ) {\n\n    rep(i,H) rep(j,W) nfield[i][j] = field[i][j];\n\n    rep(i,path.size()) nfield[path[i]/W][path[i]%W] = 1;\n\n    simulate_min(mindist2,nfield,sp[S][0]);\n\n    if( mindist2[sp[S][1]/W][sp[S][1]%W] == IINF ) return;\n\n    mini = min(mini,(int)path.size()-1+mindist2[sp[S][1]/W][sp[S][1]%W]);\n\n    return;\n\n  }\n\n  int cnt = 0;\n\n  rep(i,4) {\n\n    int nx = x + dx[i], ny = y + dy[i];\n\n    if( !isValid(nx,ny) ) continue;\n\n    cnt += visited[ny][nx];\n\n }\n\n  if( cnt >= 2 ) return;\n\n\n\n\n\n  {\n\n    rep(i,4){\n\n      int nx = x, ny = y;\n\n      nx += dx[i], ny += dy[i];\n\n      if( !isValid(nx,ny) ) continue;\n\n      if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;\n\n      if( visited[ny][nx] ) continue;\n\n      while(1){\n\n        nx += dx[i], ny += dy[i];\n\n        if( !isValid(nx,ny) ) break;\n\n        if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) break;\n\n        if( X[nx] || Y[ny] ) break;\n\n        if( visited[ny][nx] ) return;\n\n      }\n\n    }\n\n  }\n\n\n\n\n\n  rep(i,4) {\n\n    if( i == (prev+2) % 4 ) continue;\n\n    int nx = x + dx[i], ny = y + dy[i];\n\n    if( !isValid(nx,ny) ) continue;\n\n    if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;\n\n    if( visited[ny][nx] ) continue;\n\n    visited[ny][nx] = true;\n\n    path.push_back(nx+ny*W);\n\n    dfs(nx,ny,cost+1,f,ep,path,F,S,i);\n\n    path.pop_back();\n\n    visited[ny][nx] = false;\n\n  }\n\n\n\n\n\n}\n\n\n\nint compute(int F,int S){\n\n  rep(i,H) rep(j,W) visited[i][j] = false;\n\n  deque<int> path;\n\n  path.push_back(sp[F][0]);\n\n  visited[sp[F][0]/W][sp[F][0]%W] = true;\n\n  simulate_min(m1,field,sp[F][0]);\n\n  simulate_min(m2,field,sp[S][0]);\n\n  dfs(sp[F][0]%W,sp[F][0]/W,0,field,sp[F][1],path,F,S,-IINF);\n\n}\n\n\n\nint main(){\n\n  while( cin >> H >> W, H|W ){\n\n    rep(i,2) sp[i].clear();\n\n    rep(i,10) X[i] = Y[i] = false;\n\n    rep(i,H) rep(j,W) {\n\n      cin >> field[i][j];\n\n      if( field[i][j] == 1 ) X[j] = true, Y[i] = true;\n\n      if( field[i][j] == 2 ) sp[0].push_back(j+i*W), X[j] = Y[i] = true;\n\n      if( field[i][j] == 3 ) sp[1].push_back(j+i*W), X[j] = Y[i] = true;\n\n    }\n\n    mini = IINF;\n\n\n\n    compute(0,1);\n\n    if( mini == IINF ) puts(\"0\");\n\n    else cout << mini << endl;\n\n  }\n\n  return 0;\n\n}",
        "output": "#include<bits/stdc++.h>\n\n\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n\n#define rep(i,n) REP(i,0,n)\n\n\n\nusing namespace std;\n\n\n\nconst int IINF = INT_MAX;\n\n\n\nint H,W,mini,field[10][10],prev[10][10],mindist[10][10],nfield[10][10],mindist2[10][10],m1[10][10],m2[10][10];\n\nvector<int> sp[2];\n\nbool visited[10][10];\n\nint dx[] = {0,1,0,-1};\n\nint dy[] = {1,0,-1,0};\n\nbool X[10], Y[10];\n\n\n\nbool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\n\n\nvoid simulate_min(int dist[10][10],int f[10][10],int s){\n\n  rep(i,H) rep(j,W) dist[i][j] = IINF;\n\n  dist[s/W][s%W] = 0;\n\n  deque<int> deq;\n\n  deq.push_back(s);\n\n  while( !deq.empty() ){\n\n    int cur = deq.front(); deq.pop_front();\n\n    int x = cur % W, y = cur / W;\n\n    if( x+y*W != s && f[y][x] == f[s/W][s%W] ) return;\n\n    rep(i,4){\n\n      int nx = x + dx[i], ny = y + dy[i];\n\n      if( !isValid(nx,ny) ) continue;\n\n      if( f[ny][nx] != 0 && f[ny][nx] != f[s/W][s%W] ) continue;\n\n      if( dist[ny][nx] == IINF ) {\n\n        dist[ny][nx] = dist[y][x] + 1;\n\n        deq.push_back(nx+ny*W);\n\n      }\n\n    }\n\n  }\n\n}\n\n\n\n\n\nvoid dfs(int x,int y,int cost,int f[10][10],int ep,deque<int> &path,int F,int S,int prev){\n\n\n\n  if( cost >= mini ) return;\n\n  if( m1[ep/W][ep%W] - m1[y][x] + m2[sp[S][1]/W][sp[S][1]%W] + cost >= mini ) return;\n\n\n\n\n\n  if( x + y * W == ep ) {\n\n    rep(i,H) rep(j,W) nfield[i][j] = field[i][j];\n\n    rep(i,path.size()) nfield[path[i]/W][path[i]%W] = 1;\n\n    simulate_min(mindist2,nfield,sp[S][0]);\n\n    if( mindist2[sp[S][1]/W][sp[S][1]%W] == IINF ) return;\n\n    mini = min(mini,(int)path.size()-1+mindist2[sp[S][1]/W][sp[S][1]%W]);\n\n    return;\n\n  }\n\n  int cnt = 0;\n\n  rep(i,4) {\n\n    int nx = x + dx[i], ny = y + dy[i];\n\n    if( !isValid(nx,ny) ) continue;\n\n    cnt += visited[ny][nx];\n\n }\n\n  if( cnt >= 2 ) return;\n\n\n\n\n\n  {\n\n    rep(i,4){\n\n      int nx = x, ny = y;\n\n      nx += dx[i], ny += dy[i];\n\n      if( !isValid(nx,ny) ) continue;\n\n      if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;\n\n      if( visited[ny][nx] ) continue;\n\n      while(1){\n\n        nx += dx[i], ny += dy[i];\n\n        if( !isValid(nx,ny) ) break;\n\n        if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) break;\n\n        if( X[nx] || Y[ny] ) break;\n\n        if( visited[ny][nx] ) return;\n\n      }\n\n    }\n\n  }\n\n\n\n\n\n  rep(i,4) {\n\n    if( i == (prev+2) % 4 ) continue;\n\n    int nx = x + dx[i], ny = y + dy[i];\n\n    if( !isValid(nx,ny) ) continue;\n\n    if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;\n\n    if( visited[ny][nx] ) continue;\n\n    visited[ny][nx] = true;\n\n    path.push_back(nx+ny*W);\n\n    dfs(nx,ny,cost+1,f,ep,path,F,S,i);\n\n    path.pop_back();\n\n    visited[ny][nx] = false;\n\n  }\n\n\n\n\n\n}\n\n\n\nint compute(int F,int S){\n\n  rep(i,H) rep(j,W) visited[i][j] = false;\n\n  deque<int> path;\n\n  path.push_back(sp[F][0]);\n\n  visited[sp[F][0]/W][sp[F][0]%W] = true;\n\n  simulate_min(m1,field,sp[F][0]);\n\n  simulate_min(m2,field,sp[S][0]);\n\n  dfs(sp[F][0]%W,sp[F][0]/W,0,field,sp[F][1],path,F,S,-IINF);\n\n}\n\n\n\nint main(){\n\n  while( cin >> H >> W, H|W ){\n\n    rep(i,2) sp[i].clear();\n\n    rep(i,10) X[i] = Y[i] = false;\n\n    rep(i,H) rep(j,W) {\n\n      cin >> field[i][j];\n\n      if( field[i][j] == 1 ) X[j] = true, Y[i] = true;\n\n      if( field[i][j] == 2 ) sp[0].push_back(j+i*W), X[j] = Y[i] = true;\n\n      if( field[i][j] == 3 ) sp[1].push_back(j+i*W), X[j] = Y[i] = true;\n\n    }\n\n    mini = IINF;\n\n\n\n    compute(0,1);\n\n    if( mini == IINF ) puts(\"0\");\n\n    else cout << mini << endl;\n\n  }\n\n  return 0;\n\n}"
    },
    {
        "instruction": "Provide an optimized version of the following code snippet.",
        "input": "#include<bits/stdc++.h>\n\n\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n\n#define rep(i,n) REP(i,0,n)\n\n\n\nusing namespace std;\n\n\n\nconst int IINF = INT_MAX;\n\n\n\nint H,W,mini,field[10][10],prev[10][10],mindist[10][10],nfield[10][10],mindist2[10][10],m1[10][10],m2[10][10];\n\nvector<int> sp[2];\n\nbool visited[10][10];\n\nint dx[] = {0,1,0,-1};\n\nint dy[] = {1,0,-1,0};\n\nbool X[10], Y[10];\n\n\n\nbool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\n\n\nvoid simulate_min(int dist[10][10],int f[10][10],int s){\n\n  rep(i,H) rep(j,W) dist[i][j] = IINF;\n\n  dist[s/W][s%W] = 0;\n\n  deque<int> deq;\n\n  deq.push_back(s);\n\n  while( !deq.empty() ){\n\n    int cur = deq.front(); deq.pop_front();\n\n    int x = cur % W, y = cur / W;\n\n    if( x+y*W != s && f[y][x] == f[s/W][s%W] ) return;\n\n    rep(i,4){\n\n      int nx = x + dx[i], ny = y + dy[i];\n\n      if( !isValid(nx,ny) ) continue;\n\n      if( f[ny][nx] != 0 && f[ny][nx] != f[s/W][s%W] ) continue;\n\n      if( dist[ny][nx] == IINF ) {\n\n        dist[ny][nx] = dist[y][x] + 1;\n\n        deq.push_back(nx+ny*W);\n\n      }\n\n    }\n\n  }\n\n}\n\n\n\n\n\nvoid dfs(int x,int y,int cost,int f[10][10],int ep,deque<int> &path,int F,int S,int prev){\n\n\n\n  if( cost >= mini ) return;\n\n  if( m1[ep/W][ep%W] - m1[y][x] + m2[sp[S][1]/W][sp[S][1]%W] + cost >= mini ) return;\n\n\n\n\n\n  if( x + y * W == ep ) {\n\n    rep(i,H) rep(j,W) nfield[i][j] = field[i][j];\n\n    rep(i,path.size()) nfield[path[i]/W][path[i]%W] = 1;\n\n    simulate_min(mindist2,nfield,sp[S][0]);\n\n    if( mindist2[sp[S][1]/W][sp[S][1]%W] == IINF ) return;\n\n    mini = min(mini,(int)path.size()-1+mindist2[sp[S][1]/W][sp[S][1]%W]);\n\n    return;\n\n  }\n\n  int cnt = 0;\n\n  rep(i,4) {\n\n    int nx = x + dx[i], ny = y + dy[i];\n\n    if( !isValid(nx,ny) ) continue;\n\n    cnt += visited[ny][nx];\n\n }\n\n  if( cnt >= 2 ) return;\n\n\n\n\n\n  {\n\n    rep(i,4){\n\n      if( i == (prev+2) % 4 ) continue;\n\n      int nx = x, ny = y;\n\n      nx += dx[i], ny += dy[i];\n\n      if( !isValid(nx,ny) ) continue;\n\n      if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;\n\n      if( visited[ny][nx] ) continue;\n\n      while(1){\n\n        nx += dx[i], ny += dy[i];\n\n        if( !isValid(nx,ny) ) break;\n\n        if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) break;\n\n        if( X[nx] || Y[ny] ) break;\n\n        if( visited[ny][nx] ) return;\n\n      }\n\n    }\n\n  }\n\n\n\n\n\n  rep(i,4) {\n\n    if( i == (prev+2) % 4 ) continue;\n\n    int nx = x + dx[i], ny = y + dy[i];\n\n    if( !isValid(nx,ny) ) continue;\n\n    if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;\n\n    if( visited[ny][nx] ) continue;\n\n    visited[ny][nx] = true;\n\n    path.push_back(nx+ny*W);\n\n    dfs(nx,ny,cost+1,f,ep,path,F,S,i);\n\n    path.pop_back();\n\n    visited[ny][nx] = false;\n\n  }\n\n\n\n\n\n}\n\n\n\nint compute(int F,int S){\n\n  rep(i,H) rep(j,W) visited[i][j] = false;\n\n  deque<int> path;\n\n  path.push_back(sp[F][0]);\n\n  visited[sp[F][0]/W][sp[F][0]%W] = true;\n\n  simulate_min(m1,field,sp[F][0]);\n\n  simulate_min(m2,field,sp[S][0]);\n\n  dfs(sp[F][0]%W,sp[F][0]/W,0,field,sp[F][1],path,F,S,-IINF);\n\n}\n\n\n\nbool check(int a){\n\n  int x = a % W, y = a / W;\n\n  return 0 == x || W-1 == x || 0 == y || H-1 == y;\n\n}\n\n\n\nint main(){\n\n  while( cin >> H >> W, H|W ){\n\n    rep(i,2) sp[i].clear();\n\n    rep(i,10) X[i] = Y[i] = false;\n\n    rep(i,H) rep(j,W) {\n\n      cin >> field[i][j];\n\n      if( field[i][j] == 1 ) X[j] = true, Y[i] = true;\n\n      if( field[i][j] == 2 ) sp[0].push_back(j+i*W), X[j] = Y[i] = true;\n\n      if( field[i][j] == 3 ) sp[1].push_back(j+i*W), X[j] = Y[i] = true;\n\n    }\n\n    mini = IINF;\n\n    if( check(sp[0][1]) && check(sp[0][0]) && check(sp[1][1]) && check(sp[1][0]) ) {\n\n      vector<int> vec;\n\n      for(int i=0;i<W;i++) if( field[0][i] == 2 || field[0][i] == 3 ) vec.push_back(field[0][i]);\n\n      for(int i=1;i<H;i++) if( field[i][W-1] == 2 || field[i][W-1] == 3 ) vec.push_back(field[i][W-1]);\n\n      for(int i=W-2;i>=0;i--) if( field[H-1][i] == 2 || field[H-1][i] == 3 ) vec.push_back(field[H-1][i]);\n\n      for(int i=H-2;i>=1;i--) if( field[i][0] == 2 || field[i][0] == 3 ) vec.push_back(field[i][0]);\n\n      assert(vec.size() == 4);\n\n      if( !( vec[0] == vec[1] || vec[0] == vec[3] ) ) {\n\n        puts(\"0\");\n\n        continue;\n\n      }\n\n    }\n\n\n\n\n\n    compute(0,1);\n\n    if( mini == IINF ) puts(\"0\");\n\n    else cout << mini << endl;\n\n  }\n\n  return 0;\n\n}",
        "output": "#include<bits/stdc++.h>\n\n\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n\n#define rep(i,n) REP(i,0,n)\n\n\n\nusing namespace std;\n\n\n\nconst int IINF = INT_MAX;\n\n\n\nint H,W,mini,field[10][10],prev[10][10],mindist[10][10],nfield[10][10],mindist2[10][10],m1[10][10],m2[10][10];\n\nvector<int> sp[2];\n\nbool visited[10][10];\n\nint dx[] = {0,1,0,-1};\n\nint dy[] = {1,0,-1,0};\n\nbool X[10], Y[10];\n\n\n\nbool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\n\n\nvoid simulate_min(int dist[10][10],int f[10][10],int s){\n\n  rep(i,H) rep(j,W) dist[i][j] = IINF;\n\n  dist[s/W][s%W] = 0;\n\n  deque<int> deq;\n\n  deq.push_back(s);\n\n  while( !deq.empty() ){\n\n    int cur = deq.front(); deq.pop_front();\n\n    int x = cur % W, y = cur / W;\n\n    if( x+y*W != s && f[y][x] == f[s/W][s%W] ) return;\n\n    rep(i,4){\n\n      int nx = x + dx[i], ny = y + dy[i];\n\n      if( !isValid(nx,ny) ) continue;\n\n      if( f[ny][nx] != 0 && f[ny][nx] != f[s/W][s%W] ) continue;\n\n      if( dist[ny][nx] == IINF ) {\n\n        dist[ny][nx] = dist[y][x] + 1;\n\n        deq.push_back(nx+ny*W);\n\n      }\n\n    }\n\n  }\n\n}\n\n\n\n\n\nvoid dfs(int x,int y,int cost,int f[10][10],int ep,deque<int> &path,int F,int S,int prev){\n\n\n\n  if( cost >= mini ) return;\n\n  if( m1[ep/W][ep%W] - m1[y][x] + m2[sp[S][1]/W][sp[S][1]%W] + cost >= mini ) return;\n\n\n\n\n\n  if( x + y * W == ep ) {\n\n    rep(i,H) rep(j,W) nfield[i][j] = field[i][j];\n\n    rep(i,path.size()) nfield[path[i]/W][path[i]%W] = 1;\n\n    simulate_min(mindist2,nfield,sp[S][0]);\n\n    if( mindist2[sp[S][1]/W][sp[S][1]%W] == IINF ) return;\n\n    mini = min(mini,(int)path.size()-1+mindist2[sp[S][1]/W][sp[S][1]%W]);\n\n    return;\n\n  }\n\n  int cnt = 0;\n\n  rep(i,4) {\n\n    int nx = x + dx[i], ny = y + dy[i];\n\n    if( !isValid(nx,ny) ) continue;\n\n    cnt += visited[ny][nx];\n\n }\n\n  if( cnt >= 2 ) return;\n\n\n\n\n\n  {\n\n    rep(i,4){\n\n      if( i == (prev+2) % 4 ) continue;\n\n      int nx = x, ny = y;\n\n      nx += dx[i], ny += dy[i];\n\n      if( !isValid(nx,ny) ) continue;\n\n      if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;\n\n      if( visited[ny][nx] ) continue;\n\n      while(1){\n\n        nx += dx[i], ny += dy[i];\n\n        if( !isValid(nx,ny) ) break;\n\n        if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) break;\n\n        if( X[nx] || Y[ny] ) break;\n\n        if( visited[ny][nx] ) return;\n\n      }\n\n    }\n\n  }\n\n\n\n\n\n  rep(i,4) {\n\n    if( i == (prev+2) % 4 ) continue;\n\n    int nx = x + dx[i], ny = y + dy[i];\n\n    if( !isValid(nx,ny) ) continue;\n\n    if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;\n\n    if( visited[ny][nx] ) continue;\n\n    visited[ny][nx] = true;\n\n    path.push_back(nx+ny*W);\n\n    dfs(nx,ny,cost+1,f,ep,path,F,S,i);\n\n    path.pop_back();\n\n    visited[ny][nx] = false;\n\n  }\n\n\n\n\n\n}\n\n\n\nint compute(int F,int S){\n\n  rep(i,H) rep(j,W) visited[i][j] = false;\n\n  deque<int> path;\n\n  path.push_back(sp[F][0]);\n\n  visited[sp[F][0]/W][sp[F][0]%W] = true;\n\n  simulate_min(m1,field,sp[F][0]);\n\n  simulate_min(m2,field,sp[S][0]);\n\n  dfs(sp[F][0]%W,sp[F][0]/W,0,field,sp[F][1],path,F,S,-IINF);\n\n}\n\n\n\nbool check(int a){\n\n  int x = a % W, y = a / W;\n\n  return 0 == x || W-1 == x || 0 == y || H-1 == y;\n\n}\n\n\n\nint main(){\n\n  while( cin >> H >> W, H|W ){\n\n    rep(i,2) sp[i].clear();\n\n    rep(i,10) X[i] = Y[i] = false;\n\n    rep(i,H) rep(j,W) {\n\n      cin >> field[i][j];\n\n      if( field[i][j] == 1 ) X[j] = true, Y[i] = true;\n\n      if( field[i][j] == 2 ) sp[0].push_back(j+i*W), X[j] = Y[i] = true;\n\n      if( field[i][j] == 3 ) sp[1].push_back(j+i*W), X[j] = Y[i] = true;\n\n    }\n\n    mini = IINF;\n\n    if( check(sp[0][1]) && check(sp[0][0]) && check(sp[1][1]) && check(sp[1][0]) ) {\n\n      vector<int> vec;\n\n      for(int i=0;i<W;i++) if( field[0][i] == 2 || field[0][i] == 3 ) vec.push_back(field[0][i]);\n\n      for(int i=1;i<H;i++) if( field[i][W-1] == 2 || field[i][W-1] == 3 ) vec.push_back(field[i][W-1]);\n\n      for(int i=W-2;i>=0;i--) if( field[H-1][i] == 2 || field[H-1][i] == 3 ) vec.push_back(field[H-1][i]);\n\n      for(int i=H-2;i>=1;i--) if( field[i][0] == 2 || field[i][0] == 3 ) vec.push_back(field[i][0]);\n\n      assert(vec.size() == 4);\n\n      if( !( vec[0] == vec[1] || vec[0] == vec[3] ) ) {\n\n        puts(\"0\");\n\n        continue;\n\n      }\n\n    }\n\n\n\n\n\n    compute(0,1);\n\n    if( mini == IINF ) puts(\"0\");\n\n    else cout << mini << endl;\n\n  }\n\n  return 0;\n\n}"
    },
    {
        "instruction": "Provide an optimized version of the following code snippet.",
        "input": "#include<bits/stdc++.h>\n\n\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n\n#define rep(i,n) REP(i,0,n)\n\n\n\nusing namespace std;\n\n\n\nconst int IINF = INT_MAX;\n\n\n\nint H,W,mini,field[10][10],prev[10][10],mindist[10][10],nfield[10][10],mindist2[10][10],m1[10][10],m2[10][10];\n\nvector<int> sp[2];\n\nbool visited[10][10];\n\nint dx[] = {0,1,0,-1};\n\nint dy[] = {1,0,-1,0};\n\nbool X[10], Y[10];\n\n\n\nbool isValid(int x,int y) { return 0 <= x && x < W && 0 <= y && y < H; }\n\n\n\nvoid simulate_min(int dist[10][10],int f[10][10],int s){\n\n  rep(i,H) rep(j,W) dist[i][j] = IINF;\n\n  dist[s/W][s%W] = 0;\n\n  deque<int> deq;\n\n  deq.push_back(s);\n\n  while( !deq.empty() ){\n\n    int cur = deq.front(); deq.pop_front();\n\n    int x = cur % W, y = cur / W;\n\n    if( x+y*W != s && f[y][x] == f[s/W][s%W] ) return;\n\n    rep(i,4){\n\n      int nx = x + dx[i], ny = y + dy[i];\n\n      if( !isValid(nx,ny) ) continue;\n\n      if( f[ny][nx] != 0 && f[ny][nx] != f[s/W][s%W] ) continue;\n\n      if( dist[ny][nx] == IINF ) {\n\n        dist[ny][nx] = dist[y][x] + 1;\n\n        deq.push_back(nx+ny*W);\n\n      }\n\n    }\n\n  }\n\n}\n\n\n\n\n\nvoid dfs(int x,int y,int cost,int f[10][10],int ep,deque<int> &path,int F,int S,int prev){\n\n\n\n  if( cost >= mini ) return;\n\n  if( m2[sp[S][1]/W][sp[S][1]%W] + cost >= mini ) return;\n\n\n\n\n\n  if( x + y * W == ep ) {\n\n    rep(i,H) rep(j,W) nfield[i][j] = field[i][j];\n\n    rep(i,path.size()) nfield[path[i]/W][path[i]%W] = 1;\n\n    simulate_min(mindist2,nfield,sp[S][0]);\n\n    if( mindist2[sp[S][1]/W][sp[S][1]%W] == IINF ) return;\n\n    mini = min(mini,(int)path.size()-1+mindist2[sp[S][1]/W][sp[S][1]%W]);\n\n    return;\n\n  }\n\n  int cnt = 0;\n\n  rep(i,4) {\n\n    int nx = x + dx[i], ny = y + dy[i];\n\n    if( !isValid(nx,ny) ) continue;\n\n    cnt += visited[ny][nx];\n\n }\n\n  if( cnt >= 2 ) return;\n\n\n\n\n\n  {\n\n    rep(i,4){\n\n      if( i == (prev+2) % 4 ) continue;\n\n      int nx = x, ny = y;\n\n      nx += dx[i], ny += dy[i];\n\n      if( !isValid(nx,ny) ) continue;\n\n      if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;\n\n      if( visited[ny][nx] ) continue;\n\n      while(1){\n\n        nx += dx[i], ny += dy[i];\n\n        if( !isValid(nx,ny) ) break;\n\n        if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) break;\n\n        if( X[nx] || Y[ny] ) break;\n\n        if( visited[ny][nx] ) return;\n\n      }\n\n    }\n\n  }\n\n\n\n\n\n  rep(i,4) {\n\n    if( i == (prev+2) % 4 ) continue;\n\n    int nx = x + dx[i], ny = y + dy[i];\n\n    if( !isValid(nx,ny) ) continue;\n\n    if( f[ny][nx] != 0 && f[ny][nx] != f[ep/W][ep%W] ) continue;\n\n    if( visited[ny][nx] ) continue;\n\n    visited[ny][nx] = true;\n\n    path.push_back(nx+ny*W);\n\n    dfs(nx,ny,cost+1,f,ep,path,F,S,i);\n\n    path.pop_back();\n\n    visited[ny][nx] = false;\n\n  }\n\n\n\n\n\n}\n\n\n\nint compute(int F,int S){\n\n  rep(i,H) rep(j,W) visited[i][j] = false;\n\n  deque<int> path;\n\n  path.push_back(sp[F][0]);\n\n  visited[sp[F][0]/W][sp[F][0]%W] = true;\n\n  simulate_min(m1,field,sp[F][0]);\n\n  simulate_min(m2,field,sp[S][0]);\n\n  dfs(sp[F][0]%W,sp[F][0]/W,0,field,sp[F][1],path,F,S,-IINF);\n\n}\n\n\n\nbool check(int a){\n\n  int x = a % W, y = a / W;\n\n  return 0 == x || W-1 == x || 0 == y || H-1 == y;\n\n}\n\n\n\nint main(){\n\n  while( scanf(\"%d %d\",&H,&W), H|W ){\n\n    rep(i,2) sp[i].clear();\n\n    rep(i,10) X[i] = Y[i] = false;\n\n    int one = 0;\n\n    rep(i,H) rep(j,W) {\n\n      cin >> field[i][j];\n\n      if( field[i][j] == 1 ) X[j] = true, Y[i] = true, one++;\n\n      if( field[i][j] == 2 ) sp[0].push_back(j+i*W), X[j] = Y[i] = true;\n\n      if( field[i][j] == 3 ) sp[1].push_back(j+i*W), X[j] = Y[i] = true;\n\n    }\n\n    mini = H*W - one;\n\n    if( check(sp[0][1]) && check(sp[0][0]) && check(sp[1][1]) && check(sp[1][0]) ) {\n\n      vector<int> vec;\n\n      for(int i=0;i<W;i++) if( field[0][i] == 2 || field[0][i] == 3 ) vec.push_back(field[0][i]);\n\n      for(int i=1;i<H;i++) if( field[i][W-1] == 2 || field[i][W-1] == 3 ) vec.push_back(field[i][W-1]);\n\n      for(int i=W-2;i>=0;i--) if( field[H-1][i] == 2 || field[H-1][i] == 3 ) vec.push_back(field[H-1][i]);\n\n      for(int i=H-2;i>=1;i--) if( field[i][0] == 2 || field[i][0] == 3 ) vec.push_back(field[i][0]);\n\n      assert(vec.size() == 4);\n\n      if( !( vec[0] == vec[1] || vec[0] == vec[3] ) ) {\n\n        puts(\"0\");\n\n        continue;\n\n      }\n\n    }\n\n\n\n\n\n    compute(0,1);\n\n    if( mini == IINF ) puts(\"0\");\n\n    else printf(\"%d\\n\",mini);\n\n  }\n\n  return 0;\n\n}",
        "output": "#include<bits/stdc++.h>\n\n\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n\n#define rep(i,n) REP(i,0,n)\n\n\n\nusing namespace std;\n\n\n\nconst int IINF = INT_MAX;\n\nconst int MAX_W = 9;\n\ntypedef pair<int,int> ii;\n\n\n\n\n\nint h,w;\n\nint field[10][10],indice[10][10];\n\nint dp[2][1<<((MAX_W+1)*2)];\n\nint dx[] = {1,0,-1,0};\n\nint dy[] = {0,1,0,-1};\n\n\n\ninline bool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\n#define SET(bitmask,index,value) ( bitmask = ( ( bitmask & ~(1<<(2*index)) & ~(1<<(2*index+1)) ) | ( value << (index*2) ) ) )\n\n#define GET(bitmask,x) ( ( ( bitmask >> ( 2 * x ) ) & 1 ) | ( ( ( bitmask >> (2*x+1) ) & 1) << 1 ) )\n\n#define FIX(bitmask) ((bitmask<<2)&((1<<(2*(w+1)))-1))\n\n#define STAR ( field[y][x] == 2 || field[y][x] == 3 )\n\n#define update(x,v) ( ( x == -1 ) ? ( x = v ) : ( x = min(x,v) ) )\n\n\n\n\n\nvoid compute(){\n\n\n\n  set<int> S;\n\n  vector<int> state;\n\n  rep(bitmask,(1<<((w+1)*2))) {\n\n    bool success = true;\n\n    for(int i=0;i<(w+1)*2;i+=2){\n\n      if( ( ( bitmask >> i ) & 1 ) && ( ( bitmask >> (i+1) ) & 1 ) ) { success = false; break; }\n\n    }\n\n    if( success ) state.push_back(bitmask), S.insert(bitmask);\n\n  }\n\n  memset(dp,-1,sizeof(dp));\n\n\n\n  int _size = state.size();\n\n  bool initter = true, phase = false;\n\n  int mini = IINF;\n\n  int encounter = 0;\n\n  rep(y,h){\n\n    rep(x,w){\n\n      /*\n\n      cout << x << \",\" << y << endl;\n\n      rep(i,_size){\n\n        if( dp[phase][state[i]] != -1 ) {\n\n          bitset<12> BIT(state[i]);\n\n          for(int j=0;j<12;j+=2){\n\n            cout << BIT[j] << BIT[j+1] << \" \";\n\n          } \n\n          cout << \" = \" << dp[phase][state[i]] << endl;\n\n        }\n\n      }\n\n      */\n\n      if( field[y][x] == 2 || field[y][x] == 3 ) ++encounter;\n\n      if( initter ) dp[phase][0] = 0;\n\n\n\n      rep(i,_size){\n\n        int bitmask = state[i];\n\n\n\n        if( dp[phase][bitmask] == -1 ) continue;\n\n        bitset<12> bit(bitmask);\n\n\n\n\n\n        assert( S.count(bitmask));\n\n        // ?????????\n\n        if( field[y][x] == 1 ) {\n\n          int nbitmask = bitmask;\n\n          SET(nbitmask,x,0);\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n          update(dp[!phase][nbitmask],dp[phase][bitmask]);\n\n          continue;\n\n        }\n\n\n\n        int nbitmask;\n\n        // 0 0\n\n        if( !( ( GET(bitmask,x) == 0 ) && ( GET(bitmask,(x+1)) == 0 ) ) ) goto Label1;\n\n        if( STAR ) {\n\n          // x 0\n\n          if( y+1 < h && field[y+1][x] != 1 ) {\n\n            nbitmask = bitmask;\n\n            SET(nbitmask,x,((field[y][x]==3)+1));\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n\n\n            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);\n\n          }\n\n          // 0 x\n\n          if( x+1 < w && field[y][x+1] != 1 ) {\n\n            nbitmask = bitmask;\n\n            SET(nbitmask,(x+1),((field[y][x]==3)+1));\n\n\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n\n\n          update(dp[!phase][nbitmask],dp[phase][bitmask]+1);\n\n          }\n\n        } else {\n\n          // x x\n\n          if( x+1 < w && y+1 < h && field[y][x+1] != 1 && field[y+1][x] != 1 ) {\n\n            REP(color,1,3){\n\n              nbitmask = bitmask;\n\n              SET(nbitmask,x,color);\n\n              SET(nbitmask,(x+1),color);\n\n              if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n              update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));\n\n            }\n\n          }\n\n          // 0 0\n\n          nbitmask = bitmask;\n\n          SET(nbitmask,x,0);\n\n          SET(nbitmask,(x+1),0);\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n          update(dp[!phase][nbitmask],dp[phase][bitmask]);\n\n        }\n\n\n\n        continue;\n\n      Label1:;\n\n        // x 0\n\n        // 0 x\n\n        int color;\n\n        if( !( ( GET(bitmask,x) && ( GET(bitmask,(x+1)) == 0 ) ) || ( GET(bitmask,(x+1)) && ( GET(bitmask,x) == 0 ) ) ) ) goto Label2;\n\n        color = GET(bitmask,x) | GET(bitmask,(x+1));\n\n        assert( color == 1 || color == 2 );\n\n        if( STAR ) {\n\n          // 0 0\n\n          if( ((color==1)?2:3) == field[y][x] ) {\n\n\n\n            nbitmask = bitmask;\n\n            SET(nbitmask,x,0);\n\n            SET(nbitmask,(x+1),0);\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);\n\n          }\n\n        } else {\n\n          // x 0\n\n          if( y+1 < h && field[y+1][x] != 1 ) {\n\n            nbitmask = bitmask;\n\n            SET(nbitmask,x,color);\n\n            SET(nbitmask,(x+1),0);\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n\n\n\n\n            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));\n\n          }\n\n          \n\n          // 0 x\n\n          if( x+1 < w && field[y][x+1] != 1 ) {\n\n            nbitmask = bitmask;\n\n            SET(nbitmask,x,0);\n\n            SET(nbitmask,(x+1),color);\n\n\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));\n\n          }\n\n        }\n\n        continue;\n\n      Label2:;\n\n        // x x\n\n        if( !( GET(bitmask,x) && GET(bitmask,(x+1)) ) ) goto Label3;\n\n        if( GET(bitmask,x) != GET(bitmask,(x+1)) ) goto Label3;\n\n\n\n        color = GET(bitmask,x);\n\n        assert( color );\n\n        //assert( GET(bitmask,x) == GET(bitmask,(x+1)) );\n\n        \n\n        // 0 0\n\n        if( !STAR ) {\n\n          nbitmask = bitmask;\n\n          SET(nbitmask,x,0);\n\n          SET(nbitmask,(x+1),0);\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n          update(dp[!phase][nbitmask],dp[phase][bitmask]+1);\n\n        }\n\n      Label3:;\n\n\n\n      }\n\n      if( field[y][x] == 2 || field[y][x] == 3 ) initter = false;\n\n      rep(i,_size) dp[phase][state[i]] = -1;\n\n      if( encounter >= 4 && dp[!phase][0] != -1 ) {\n\n        mini = min(mini,dp[!phase][0]);\n\n      }\n\n      phase = !phase;\n\n    }\n\n  }\n\n\n\n  /*\n\n  puts(\"final\");\n\n  rep(i,_size){\n\n    if( dp[phase][state[i]] != -1 ) {\n\n      bitset<12> BIT(state[i]);\n\n      for(int j=0;j<12;j+=2){\n\n        cout << BIT[j] << BIT[j+1] << \" \";\n\n      } \n\n      cout << \" = \" << dp[phase][state[i]] << endl;\n\n    }\n\n  }\n\n  */\n\n  if( dp[phase][0] != -1 ) mini = min(mini,dp[phase][0]);\n\n  if( mini != IINF ) printf(\"%d\\n\",mini-2);\n\n  else puts(\"0\");\n\n}\n\n\n\nint main(){\n\n\n\n\n\n  while( scanf(\"%d %d\",&h,&w), h|w ){\n\n    rep(i,h) rep(j,w) scanf(\"%d\",&field[i][j]);\n\n    compute();\n\n  }\n\n  return 0;\n\n}"
    },
    {
        "instruction": "Provide an optimized version of the following code snippet.",
        "input": "#include<bits/stdc++.h>\n\n\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n\n#define rep(i,n) REP(i,0,n)\n\n\n\nusing namespace std;\n\n\n\nconst int IINF = INT_MAX;\n\nconst int MAX_W = 9;\n\ntypedef pair<int,int> ii;\n\n\n\n\n\nint h,w;\n\nint field[10][10],indice[10][10];\n\nint dp[2][1<<((MAX_W+1)*2)];\n\nint dx[] = {1,0,-1,0};\n\nint dy[] = {0,1,0,-1};\n\n\n\ninline bool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\n#define SET(bitmask,index,value) ( bitmask = ( ( bitmask & ~(1<<(2*index)) & ~(1<<(2*index+1)) ) | ( value << (index*2) ) ) )\n\n#define GET(bitmask,x) ( ( ( bitmask >> ( 2 * x ) ) & 1 ) | ( ( ( bitmask >> (2*x+1) ) & 1) << 1 ) )\n\n#define FIX(bitmask) ((bitmask<<2)&((1<<(2*(w+1)))-1))\n\n#define STAR ( field[y][x] == 2 || field[y][x] == 3 )\n\n#define update(x,v) ( ( x == -1 ) ? ( x = v ) : ( x = min(x,v) ) )\n\n\n\n\n\nvoid compute(){\n\n\n\n  set<int> S;\n\n  vector<int> state;\n\n  rep(bitmask,(1<<((w+1)*2))) {\n\n    bool success = true;\n\n    for(int i=0;i<(w+1)*2;i+=2){\n\n      if( ( ( bitmask >> i ) & 1 ) && ( ( bitmask >> (i+1) ) & 1 ) ) { success = false; break; }\n\n    }\n\n    if( success ) state.push_back(bitmask), S.insert(bitmask);\n\n  }\n\n  memset(dp,-1,sizeof(dp));\n\n\n\n  int _size = state.size();\n\n  bool initter = true, phase = false;\n\n  int mini = IINF;\n\n  int encounter = 0;\n\n  rep(y,h){\n\n    rep(x,w){\n\n      /*\n\n      cout << x << \",\" << y << endl;\n\n      rep(i,_size){\n\n        if( dp[phase][state[i]] != -1 ) {\n\n          bitset<12> BIT(state[i]);\n\n          for(int j=0;j<12;j+=2){\n\n            cout << BIT[j] << BIT[j+1] << \" \";\n\n          } \n\n          cout << \" = \" << dp[phase][state[i]] << endl;\n\n        }\n\n      }\n\n      */\n\n      if( field[y][x] == 2 || field[y][x] == 3 ) ++encounter;\n\n      if( initter ) dp[phase][0] = 0;\n\n\n\n      rep(i,_size){\n\n        int bitmask = state[i];\n\n\n\n        if( dp[phase][bitmask] == -1 ) continue;\n\n        bitset<12> bit(bitmask);\n\n\n\n\n\n        assert( S.count(bitmask));\n\n        // ?????????\n\n        if( field[y][x] == 1 ) {\n\n          int nbitmask = bitmask;\n\n          SET(nbitmask,x,0);\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n          update(dp[!phase][nbitmask],dp[phase][bitmask]);\n\n          continue;\n\n        }\n\n\n\n        int nbitmask;\n\n        // 0 0\n\n        if( !( ( GET(bitmask,x) == 0 ) && ( GET(bitmask,(x+1)) == 0 ) ) ) goto Label1;\n\n        if( STAR ) {\n\n          // x 0\n\n          if( y+1 < h && field[y+1][x] != 1 ) {\n\n            nbitmask = bitmask;\n\n            SET(nbitmask,x,((field[y][x]==3)+1));\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n\n\n            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);\n\n          }\n\n          // 0 x\n\n          if( x+1 < w && field[y][x+1] != 1 ) {\n\n            nbitmask = bitmask;\n\n            SET(nbitmask,(x+1),((field[y][x]==3)+1));\n\n\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n\n\n          update(dp[!phase][nbitmask],dp[phase][bitmask]+1);\n\n          }\n\n        } else {\n\n          // x x\n\n          if( x+1 < w && y+1 < h && field[y][x+1] != 1 && field[y+1][x] != 1 ) {\n\n            REP(color,1,3){\n\n              nbitmask = bitmask;\n\n              SET(nbitmask,x,color);\n\n              SET(nbitmask,(x+1),color);\n\n              if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n              update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));\n\n            }\n\n          }\n\n          // 0 0\n\n          nbitmask = bitmask;\n\n          SET(nbitmask,x,0);\n\n          SET(nbitmask,(x+1),0);\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n          update(dp[!phase][nbitmask],dp[phase][bitmask]);\n\n        }\n\n\n\n        continue;\n\n      Label1:;\n\n        // x 0\n\n        // 0 x\n\n        int color;\n\n        if( !( ( GET(bitmask,x) && ( GET(bitmask,(x+1)) == 0 ) ) || ( GET(bitmask,(x+1)) && ( GET(bitmask,x) == 0 ) ) ) ) goto Label2;\n\n        color = GET(bitmask,x) | GET(bitmask,(x+1));\n\n        assert( color == 1 || color == 2 );\n\n        if( STAR ) {\n\n          // 0 0\n\n          if( ((color==1)?2:3) == field[y][x] ) {\n\n\n\n            nbitmask = bitmask;\n\n            SET(nbitmask,x,0);\n\n            SET(nbitmask,(x+1),0);\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);\n\n          }\n\n        } else {\n\n          // x 0\n\n          if( y+1 < h && field[y+1][x] != 1 ) {\n\n            nbitmask = bitmask;\n\n            SET(nbitmask,x,color);\n\n            SET(nbitmask,(x+1),0);\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n\n\n\n\n            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));\n\n          }\n\n          \n\n          // 0 x\n\n          if( x+1 < w && field[y][x+1] != 1 ) {\n\n            nbitmask = bitmask;\n\n            SET(nbitmask,x,0);\n\n            SET(nbitmask,(x+1),color);\n\n\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));\n\n          }\n\n        }\n\n        continue;\n\n      Label2:;\n\n        // x x\n\n        if( !( GET(bitmask,x) && GET(bitmask,(x+1)) ) ) goto Label3;\n\n        if( GET(bitmask,x) != GET(bitmask,(x+1)) ) goto Label3;\n\n\n\n        color = GET(bitmask,x);\n\n        assert( color );\n\n        //assert( GET(bitmask,x) == GET(bitmask,(x+1)) );\n\n        \n\n        // 0 0\n\n        if( !STAR ) {\n\n          nbitmask = bitmask;\n\n          SET(nbitmask,x,0);\n\n          SET(nbitmask,(x+1),0);\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n          update(dp[!phase][nbitmask],dp[phase][bitmask]+1);\n\n        }\n\n      Label3:;\n\n\n\n      }\n\n      if( field[y][x] == 2 || field[y][x] == 3 ) initter = false;\n\n      rep(i,_size) dp[phase][state[i]] = -1;\n\n      if( encounter >= 4 && dp[!phase][0] != -1 ) {\n\n        mini = min(mini,dp[!phase][0]);\n\n      }\n\n      phase = !phase;\n\n    }\n\n  }\n\n\n\n  /*\n\n  puts(\"final\");\n\n  rep(i,_size){\n\n    if( dp[phase][state[i]] != -1 ) {\n\n      bitset<12> BIT(state[i]);\n\n      for(int j=0;j<12;j+=2){\n\n        cout << BIT[j] << BIT[j+1] << \" \";\n\n      } \n\n      cout << \" = \" << dp[phase][state[i]] << endl;\n\n    }\n\n  }\n\n  */\n\n  if( dp[phase][0] != -1 ) mini = min(mini,dp[phase][0]);\n\n  if( mini != IINF ) printf(\"%d\\n\",mini-2);\n\n  else puts(\"0\");\n\n}\n\n\n\nint main(){\n\n\n\n\n\n  while( scanf(\"%d %d\",&h,&w), h|w ){\n\n    rep(i,h) rep(j,w) scanf(\"%d\",&field[i][j]);\n\n    compute();\n\n  }\n\n  return 0;\n\n}",
        "output": "#include<bits/stdc++.h>\n\n\n\n#define REP(i,s,n) for(int i=s;i<n;i++)\n\n#define rep(i,n) REP(i,0,n)\n\n\n\nusing namespace std;\n\n\n\nconst int IINF = INT_MAX;\n\nconst int MAX_W = 9;\n\ntypedef pair<int,int> ii;\n\n\n\n\n\nint h,w;\n\nint field[10][10],indice[10][10];\n\nint dp[2][1<<((MAX_W+1)*2)];\n\nint dx[] = {1,0,-1,0};\n\nint dy[] = {0,1,0,-1};\n\n\n\ninline bool isValid(int x,int y) { return 0 <= x && x < w && 0 <= y && y < h; }\n\n\n\n#define SET(bitmask,index,value) ( bitmask = ( ( bitmask & ~(1<<(2*index)) & ~(1<<(2*index+1)) ) | ( value << (index*2) ) ) )\n\n#define GET(bitmask,x) ( ( ( bitmask >> ( 2 * x ) ) & 1 ) | ( ( ( bitmask >> (2*x+1) ) & 1) << 1 ) )\n\n#define FIX(bitmask) ((bitmask<<2)&((1<<(2*(w+1)))-1))\n\n#define STAR ( field[y][x] == 2 || field[y][x] == 3 )\n\n#define update(x,v) ( ( x == -1 ) ? ( x = v ) : ( x = min(x,v) ) )\n\n\n\n\n\nvoid compute(){\n\n\n\n  vector<int> state;\n\n  rep(bitmask,(1<<((w+1)*2))) {\n\n    bool success = true;\n\n    for(int i=0;i<(w+1)*2;i+=2) if( ( ( bitmask >> i ) & 1 ) && ( ( bitmask >> (i+1) ) & 1 ) ) { success = false; break; }\n\n    if( success ) state.push_back(bitmask);\n\n  }\n\n  memset(dp,-1,sizeof(dp));\n\n\n\n  int _size = state.size();\n\n  bool initter = true, phase = false;\n\n  int mini = IINF;\n\n  int encounter = 0;\n\n  rep(y,h){\n\n    rep(x,w){\n\n\n\n      if( field[y][x] == 2 || field[y][x] == 3 ) ++encounter;\n\n      if( initter ) dp[phase][0] = 0;\n\n\n\n      rep(i,_size){\n\n        int bitmask = state[i];\n\n\n\n        if( dp[phase][bitmask] == -1 ) continue;\n\n\n\n        // ?????????\n\n        if( field[y][x] == 1 ) {\n\n          int nbitmask = bitmask;\n\n          SET(nbitmask,x,0);\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n          update(dp[!phase][nbitmask],dp[phase][bitmask]);\n\n          continue;\n\n        }\n\n\n\n        int nbitmask;\n\n        // 0 0\n\n        if( !( ( GET(bitmask,x) == 0 ) && ( GET(bitmask,(x+1)) == 0 ) ) ) goto Label1;\n\n        if( STAR ) {\n\n          // x 0\n\n          if( y+1 < h && field[y+1][x] != 1 ) {\n\n            nbitmask = bitmask;\n\n            SET(nbitmask,x,((field[y][x]==3)+1));\n\n            if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n          \n\n            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);\n\n          }\n\n          // 0 x\n\n          if( x+1 < w && field[y][x+1] != 1 ) {\n\n            nbitmask = bitmask;\n\n            SET(nbitmask,(x+1),((field[y][x]==3)+1));\n\n\n\n            if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n\n\n            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);\n\n          }\n\n        } else {\n\n          // x x\n\n          if( x+1 < w && y+1 < h && field[y][x+1] != 1 && field[y+1][x] != 1 ) {\n\n            REP(color,1,3){\n\n              nbitmask = bitmask;\n\n              SET(nbitmask,x,color);\n\n              SET(nbitmask,(x+1),color);\n\n              if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n              update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));\n\n            }\n\n          }\n\n          // 0 0\n\n          nbitmask = bitmask;\n\n          SET(nbitmask,x,0);\n\n          SET(nbitmask,(x+1),0);\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n          update(dp[!phase][nbitmask],dp[phase][bitmask]);\n\n        }\n\n\n\n        continue;\n\n      Label1:;\n\n        // x 0\n\n        // 0 x\n\n        int color;\n\n        if( !( ( GET(bitmask,x) && ( GET(bitmask,(x+1)) == 0 ) ) || ( GET(bitmask,(x+1)) && ( GET(bitmask,x) == 0 ) ) ) ) goto Label2;\n\n        color = GET(bitmask,x) | GET(bitmask,(x+1));\n\n        if( STAR ) {\n\n          // 0 0\n\n          if( ((color==1)?2:3) == field[y][x] ) {\n\n            nbitmask = bitmask;\n\n            SET(nbitmask,x,0);\n\n            SET(nbitmask,(x+1),0);\n\n            if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n            update(dp[!phase][nbitmask],dp[phase][bitmask]+1);\n\n          }\n\n        } else {\n\n          // x 0\n\n          if( y+1 < h && field[y+1][x] != 1 ) {\n\n            nbitmask = bitmask;\n\n            SET(nbitmask,x,color);\n\n            SET(nbitmask,(x+1),0);\n\n            if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n\n\n\n\n            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));\n\n          }\n\n          \n\n          // 0 x\n\n          if( x+1 < w && field[y][x+1] != 1 ) {\n\n            nbitmask = bitmask;\n\n            SET(nbitmask,x,0);\n\n            SET(nbitmask,(x+1),color);\n\n\n\n            if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n            update(dp[!phase][nbitmask],(dp[phase][bitmask]+1));\n\n          }\n\n        }\n\n        continue;\n\n      Label2:;\n\n        // x x\n\n        if( !( GET(bitmask,x) && GET(bitmask,(x+1)) ) ) goto Label3;\n\n        if( GET(bitmask,x) != GET(bitmask,(x+1)) ) goto Label3;\n\n\n\n        color = GET(bitmask,x);\n\n        \n\n        // 0 0\n\n        if( !STAR ) {\n\n          nbitmask = bitmask;\n\n          SET(nbitmask,x,0);\n\n          SET(nbitmask,(x+1),0);\n\n          if( x == w-1 ) nbitmask = FIX(nbitmask);\n\n          update(dp[!phase][nbitmask],dp[phase][bitmask]+1);\n\n        }\n\n      Label3:;\n\n\n\n      }\n\n      if( field[y][x] == 2 || field[y][x] == 3 ) initter = false;\n\n      rep(i,_size) dp[phase][state[i]] = -1;\n\n      if( encounter >= 4 && dp[!phase][0] != -1 ) {\n\n        mini = min(mini,dp[!phase][0]);\n\n      }\n\n      phase = !phase;\n\n    }\n\n  }\n\n  if( dp[phase][0] != -1 ) mini = min(mini,dp[phase][0]);\n\n  if( mini != IINF ) printf(\"%d\\n\",mini-2);\n\n  else puts(\"0\");\n\n}\n\n\n\nint main(){\n\n  while( scanf(\"%d %d\",&h,&w), h|w ){\n\n    rep(i,h) rep(j,w) scanf(\"%d\",&field[i][j]);\n\n    compute();\n\n  }\n\n  return 0;\n\n}"
    }
]